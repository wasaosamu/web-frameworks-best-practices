# 第4章：キャッシュと再検証

**この章の目標**  
「キャッシュ」とは、**一度取ったデータを一時的に保管しておき、同じデータを何度も取りに行かないようにする**仕組みです。  
Next.jsでは、**fetch** するときに「どのくらいの間キャッシュを使うか」「常に最新を取りに行くか」を指定できます。  
この章では、その考え方と書き方を、初心者向けに説明します。

---

## キャッシュとは？（日常生活の例でイメージ）

- **キャッシュ** = よく使う結果を「手元に控え」として持っておくことです。  
  例：天気予報を「1時間は同じ結果を表示してよい」と決めておけば、その1時間は同じデータを何度も取りに行かずに済みます。

- **再検証（リバリデーション）** = 「控え」が古くなっていないか確認し、必要なら新しいデータに差し替えることです。  
  例：「1時間たったら、もう一度最新の天気を取ってきて、表示を更新する」というルールにすることです。

Next.jsの **fetch** では、  
「このデータは〇秒（または〇時間）キャッシュしてよい」「このデータはキャッシュせず、毎回最新を取りに行く」  
といった**方針**を指定できます。

---

## なぜキャッシュを意識するのか？

- **キャッシュしすぎ**  
  データが古いまま長時間表示され、「更新したのに画面が変わらない」という不満につながります。

- **キャッシュしない**  
  毎回サーバーやAPIに問い合わせるため、応答が遅くなったり、相手のサービスに負荷をかけたりしやすくなります。

なので、  
- **あまり変わらないデータ**（例：商品一覧、ブログ記事）→ 一定時間キャッシュしてよい  
- **常に最新でないといけないデータ**（例：在庫数、管理画面）→ キャッシュしない（毎回取得）  

というように、**データの性質に合わせて**設定することがベストプラクティスです。

---

## fetch でキャッシュを指定する

Next.jsでは、**fetch** の第2引数に `next` オプションを渡すことで、キャッシュの振る舞いを指定します。

### パターン1：一定時間キャッシュして、その後再検証（ISR 的な動き）

「〇秒（または〇時間）はキャッシュを使い、それを過ぎたらバックグラウンドで最新を取る」という指定です。

```ts
// revalidate: 秒数 で「この秒数が経過したら、次にアクセスしたときにデータを再取得する」という意味になります
const res = await fetch("https://api.example.com/products", {
  next: { revalidate: 3600 },
  // 3600 秒 = 1 時間。1時間は同じ結果を使い、その後は新しいデータを取りに行きます
});
```

- **変更が少ないデータ**（一覧ページ、記事一覧、よく変わらない設定など）に向いています。  
- コメントや関数名で「一覧のISR用」「1時間キャッシュ」など目的を書いておくと、あとで見直しやすくなります。

### パターン2：常に最新を取りに行く（キャッシュしない）

「毎回必ずサーバーやAPIに問い合わせる」という指定です。

```ts
const res = await fetch("https://api.example.com/admin/orders", {
  cache: "no-store",
  // 「キャッシュに頼らず、毎回最新のデータを取得する」という意味です
});
```

- **常に最新が必要なデータ**（在庫、注文一覧、管理画面など）に向いています。  
- コメントで「管理画面用・常に最新」など書いておくと分かりやすいです。

---

## 例題：用途別の fetch の書き方

次の例は、  
- 商品一覧：1時間キャッシュ（変更が少ないと想定）  
- 管理画面の注文一覧：常に最新  

という方針で書いたイメージです。各行にコメントを付けています。

```tsx
// ファイル名の例: app/products/page.tsx（商品一覧・変更が少ない想定）
export default async function ProductsPage() {
  const res = await fetch("https://api.example.com/products", {
    next: { revalidate: 3600 },
    // 商品一覧はそんなに頻繁に変わらないので、1時間はキャッシュして負荷を減らす
  });

  const products = await res.json();
  return (
    <div>
      <h1>商品一覧</h1>
      {/* ... 表示 ... */}
    </div>
  );
}
```

```tsx
// ファイル名の例: app/admin/orders/page.tsx（管理画面・常に最新が必要）
export default async function AdminOrdersPage() {
  const res = await fetch("https://api.example.com/admin/orders", {
    cache: "no-store",
    // 管理画面では常に最新の注文を見たいので、キャッシュを使わない
  });

  const orders = await res.json();
  return (
    <div>
      <h1>注文一覧（管理用）</h1>
      {/* ... 表示 ... */}
    </div>
  );
}
```

---

## キャッシュ方針をコメントで残す

「なぜこの秒数にしたか」「なぜ no-store にしたか」を、コード上で分かるようにしておくと、  
あとから「このページ、もっとキャッシュしていいのでは？」「ここは最新にしたい」という判断がしやすくなります。

```ts
// 一覧のISR：1時間キャッシュ（商品マスタは日中あまり変わらない前提）
const res = await fetch(url, { next: { revalidate: 3600 } });

// 管理画面は常に最新
const res = await fetch(url, { cache: "no-store" });
```

---

## まとめ

- **キャッシュ** = 一度取ったデータを一時保管し、同じ問い合わせを減らす仕組み。  
  **再検証** = そのデータを「いつ最新に更新するか」のルール。
- 変更が少ないデータ → `fetch(url, { next: { revalidate: 秒数 } })` で一定時間キャッシュ。  
  常に最新が必要なデータ → `fetch(url, { cache: "no-store" })` でキャッシュしない。
- どの方針にしたかは、コメントや関数名で目的（「一覧のISR」「管理画面は no-store」など）を書いておくとよい。

次章では、**環境変数とセキュリティ**（秘密のキーやパスワードの扱い方）を説明します。
