# 第8章：リスト内包表記・ジェネレータ・with 文

**この章の目標**  
Python の**便利な書き方**を学びます。  
リスト内包表記、ジェネレータ、with 文（コンテキストマネージャ）を、初心者向けに説明します。

---

## リスト内包表記とは？

**リスト内包表記**は、**リストを短く書く**ための書き方です。

```python
# 通常の書き方
squares = []              # 空のリストを用意
for x in range(5):        # 0〜4 をループ
    squares.append(x * x) # 二乗をリストに追加

# リスト内包表記（同じ処理を1行で書く）
squares = [x * x for x in range(5)]  # range(5) の各 x に対して x*x を集めたリスト
# 結果: [0, 1, 4, 9, 16]
```

- `[式 for 変数 in イテラブル]` の形  
- 条件を付けたいときは `[式 for 変数 in イテラブル if 条件]`  

```python
# 偶数だけにする（if で条件を付けたリスト内包表記）
evens = [x for x in range(10) if x % 2 == 0]  # 0〜9 のうち 2 で割り切れるものだけ
# 結果: [0, 2, 4, 6, 8]
```

---

## 辞書内包表記

```python
# キーと値のペアから辞書を作る
names = ["山田", "佐藤", "鈴木"]  # 元のリスト
user_ids = {name: i for i, name in enumerate(names)}  # enumerate でインデックスと要素を取得し、名前:インデックス の辞書を作成
# 結果: {"山田": 0, "佐藤": 1, "鈴木": 2}
```

---

## ジェネレータとは？

**ジェネレータ**は、**1つずつ値を返す**仕組みです。メモリを節約できます。

```python
def count_up(n):          # ジェネレータ関数（yield を使う）
    i = 0
    while i < n:
        yield i           # yield で1つずつ値を返す（一時停止して再開可能）
        i += 1            # 次のループ用にインクリメント

for x in count_up(5):     # ジェネレータから順に値を取り出す
    print(x)              # 0, 1, 2, 3, 4 を順に出力
```

- **yield** を使うと、その関数はジェネレータになる  
- リストに全部入れる代わりに、必要になったときだけ次の値を返す  

---

## with 文（コンテキストマネージャ）

**with 文**は、**リソースの開閉を安全に扱う**ための書き方です。

```python
# ファイルを開いて、終わったら自動で閉じる（with 文）
with open("file.txt", "r") as f:  # ファイルを開き、f にバインド（"r" は読み込みモード）
    content = f.read()            # ファイル内容を読み込む
# ブロックを出たら、自動で f.close() が呼ばれる（エラー時も閉じられる）
```

- ファイルやデータベース接続など、「開いたら必ず閉じる」ものに使う  
- エラーが起きても、きちんと閉じられる  

---

## まとめ

- **リスト内包表記**で、リストを簡潔に書ける。`[式 for 変数 in イテラブル]`。
- **ジェネレータ**で、メモリを節約しながら1つずつ値を返せる。`yield` を使う。
- **with 文**で、ファイルなどを安全に開閉できる。
